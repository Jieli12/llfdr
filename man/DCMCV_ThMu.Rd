% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DCMCV_ThMu.R
\name{DCMCV_ThMu}
\alias{DCMCV_ThMu}
\title{DCMCV_ThMu}
\usage{
DCMCV_ThMu(Yi, u, Index.obs, u0, h, r, ktype = "gaussian")
}
\arguments{
\item{Yi}{the p * n matrix}

\item{u}{the condition, it is a vector, one-dimensional array or
one-dimensional row(column) matrix}

\item{Index.obs}{the index of observation}

\item{u0}{the given condition to be estimated. The default is NULL.
If u0 is NULL, then u0 = u.}

\item{h}{the  bandwidth}

\item{r}{the threshold value}

\item{ktype}{the kernel type, can be "gaussian", "epanech", "triweight",
"biweight", "tricube", "triangular" and "cosine",
the default of ktype is "gaussian".}
}
\value{
the value of cross validation function
}
\description{
This routine computes the goal function for optimal threshold value
}
\examples{
\dontrun{

data(u)
data(Y)
data(Index.obs)
data(hdcm2)
u <- as.vector(u)

u0_len <- 25
u0 <- seq(-0.9, 0.9, length.out = u0_len)
a <- 0
bcoef <- 0.6
thdcm2  <- rep(0, u0_len)
for (i in 1:u0_len) {
    b2 <- bcoef * max(Cov_EstMu(Y = Y, u = u, u0 = u0[i], h = hdcm2$minimum))
    thdcm2_temp <- optimise(DCMCV_ThMu, c(a, b2), tol = 1e-6, Yi = Y, u = u,
                  Index.obs = Index.obs, u0 = u0[i], h = hdcm2$minimum)
    thdcm2[i] <-thdcm2_temp$minimum
}
}
}
\seealso{
\code{\link{DCMCVhMu}}, \code{\link{Cov_EstMu}}
}
